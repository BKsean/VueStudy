1. node 설치
2. npm으로 Vue설치
3. npm으로 vue cli 설치
4. 원하는 프로젝트에서 vue cli로 create vue 프로젝트명으로 프로젝트 생성
5. vscode에서 해당 폴더 불러오고 vetur패키지? 설치
6. package.json --> 사용하기위한 dependency등록   **패키지 추가 등록시 리로드는 어떻게?
7. index.html --> 빌드하면 나중에 스크립트가 자동으로 들어간다는데?
8. main.js 

* TypeScript와같이 사용하는 방법
* 해당 js및 html을 MVC프로젝트에 적용방법
* thymleaf? 와 같이 사용하는 방법

======================================================================================================

*기본적인 구조
<template>  //html코드값 들어감
    <div></div>
</template>


<script></script>

<style></style>

*함수생성

*이벤트 매핑

*이벤트로 변수 변경
*ref와 reactive
 ref와 reactive의 차이점
타입 제한
ref에서는 String, Number, Object 등 어떠한 타입에서도 사용할 수 있습니다.
반면 reactive에서는 Object, array, Map, Set과 같은 타입에서만 사용할 수 있습니다.

접근 방식
ref에서는 .value property를 붙여 접근할 수 있습니다. <templete>에서 변수를 명시할 때에는 붙일 필요가 없습니다.
reactive에서는 .value를 붙일 필요가 없이 <templete>에서 사용하는 자바스크립트 문법처럼 사용하시면 됩니다.

*데이터 바인딩
v-bind:class --> :class 로사용가능
v-on:click --> @click 로 사용가능
v-model ---> 양방향으로 데이터 매핑 가능 @input 으로 value값 변경 이벤트를 바인딩할 필요가 없음
v-for="a in todos" v-bind:key="a.id"

v-show --> 아닌경우에 DOM에 존재하지만 display:none상태임
<div v-show="toggle">true</div>
<div v-show="!toggle">flase</div>

v-if  --> 아닌경우에 DOM에서 없어짐
<div v-if="toggle">true</div>
<div v-else>false</div>

*체크박스 바인딩
<input class="form-check-input" type="checkbox" v-model="a.completed">
        <label
          class="form-check-label"
        >{{ a.subject }}</label>

*스타일,class바인딩
<label
          class="form-check-label" :style="a.completed ? complete : {}"
        :class="{active : a.completed}">{{ a.subject }}</label>

const complete = {
      textDecoration: 'line-through',
      color: 'gray'
    }

<style>
.active{
  font-size: 15px;
  color: rgb(19, 19, 212);
}
</style>

*해야할일 삭제
<button class="btn btn-danger btn-sm" @click="removeTodo(a.id)">삭제</button>
const removeTodo = (id)=>{
    todos.value.pop(id);
  }

  *컴포넌트 분리 
  새로운 .VUE파일을 만들어서 코드의 복잡성및 유지보수성을 위해 컴포넌트를 분리한다. 
  import TodoSimpleForm from './components/TodoSimple.vue';
export default {
  components:{
    TodoSimpleForm,
},

*분리된 컴포넌트를 부모에서 사용
<TodoSimpleForm/>

  *컴포넌트로 분리시 부모 컴포넌트에 데이터 전달 방법
  setup(props,context){ 으로 setup파라미터 설정
   context.emit('add-todo',{
             id: Date.now(),
             subject: todo.value,
             completed:false
             });
으로 데이터 전달 여기선 객체 
부모 컴포넌트에서 자식컴포넌트 사용부분에섯 받는 데이터 설정
<TodoSimpleForm @add-todo="addTodo*이건이벤트 함수" />


*부모컴포넌트에서 자식컴포넌트로 데이터 전송
컴포넌트 분리후 부모에서 자식컴포넌트 사용하는 부분에 다음과 같이 데이터 전송
<TodoList :todos<-이건 전달되는 변수="todos"/> 

자식 컴포넌트에서 데이터 바는 방법
export default{
        props: ['todos']
        // props: {  이것과 같이 타입,필수여부등을 설정가능
        //     todos:{
        //         type: Array,
        //         required: true
        //     }
        // }
    }

    &&주의할점 props로 전달되는 데이터는 one way data flow다 
    즉 자식에서 변경해봤자 데이터가 변경되지 않는다. 변경하려면
    부모 컴포넌트에서 변경할것

    emits옵션? 자식 컴포넌트는 하나의 html태크로 감싸줘야한다?
    --> 그대로 되지만 emits: ['toggle-todo','delete-todo']로 해당 컴포넌트에서 사용중인 emit이름들을 정리하면 된다.
    
    setup(props,{emit--> context대신 emit만 꺼내와서 사용가능}){
            const toggleTodo=(index) =>{
                emit('toggle-todo',index); //부모 컴포넌트에 toggle-todo라는 이름으로 index데이터 전달
            }

            const removeTodo=(id) =>{
                emit('delete-todo',id); //부모 컴포넌트에 toggle-todo라는 이름으로 index데이터 전달
            }
            
            
            return{
            toggleTodo,removeTodo
        }
        }

*Computed
import {computed} from 'vue';
let count = ref(1);
let doubleCount = computed(() => {
  return count.value *2;
});

count의 값의 변경을 감지하여 doubleCount호출시 자동으로 변경된
count값의 *2를 하여 반환한다. 

<h3>doubleCountComputed : {{ doubleCountComputed }}</h3>
<h3>doubleCountMethod : {{ doubleCountMethod() }}</h3>

const doubleCountMethod = () =>{
      return count.value *2;
    }

computed와 method의 차이점
computed는 호출하는것을 보면 알수있듯이 값을 리턴한다. ()를안쓴다는 뜻
computed는 파라미터를 받을 수없다
참조변수가 변경될때 실행한다
computed는 값을 캐쉬한다. (즉 여러번사용할떄 함수는 사용할떄마다 실행되지만 computed는 한번 실행되면 해당 값을 캐쉬하기때문에 재실행되지 않는다.)

TOdoDb에저장하기
npm으로 가상 json뭐시기 설치하지 restful하게 사용할 수있는 DB를 제공해줬다

async/await

async 키워드를 함수 압에 사용하면 해당 함수는 비동기가된다
await 를 사용하면 axios요청의 응답을 기다린다는 뜻
 const addTodo = async (object) => {
      //데이터베이스에 todo저장 post request이용
      const res = await axios.post('http://localhost:3000/todos',{
        subject: object.subject,
        completed: object.completed
      })
        
    }

    *axios를 이용해 데이터 입력 및 삭제 구현
    *axios를 이용해 데이터 변경
    --> put,patch 메소드를 사용할수 있는데 
    put: 데이터 전체를 변경할떄
    patch : 데이터 일부분만 변경할때 
    사용된다고 한다. 


*Pagination
한페이지당 보여줄 게시물개수, 전체 개시물개수 만있으면
페이지 네이션 컨트롤 가능 
추가로 5개 페이지만 표시하고 싶다 + 5번째 페이지 이후 넥스트페이지 선택시 6,7,8,9,10 으로 표시되도록 하는것
추가로 마지막 페이지 이동 등등 추가 필요

*watfch effect
import { ref,watchEffect} from 'vue';
    watchEffect(()=>{
      console.log(numberOfPages.value);
    })

    뷰에서 관리되는 변수가 변경되면 감지해서 자동으로 실행하는 함수
    ref,reactive,props등등 다 적용됨

  *watch
  watchEffect와 비슷하다
    watch(currentPage(관리할 변수),(currentPage,prev(변경되기전 변수값)) =>{
      console.log(currentPage,prev);
    })

    reactive의 경우 객체이기 때문에 객체안에 특정값으로 watch가능
    watch(()=>a.b,(current,prev)=>{
      ....
    })
    여러값 watch
    watch(()=>[a.b,a.c],(current,prev)=>{
      .... 결과값도 배열로 나온다.
    })

    검색부분에 watch를 적용하여 키보드 입력시 변경 감지를 통해 getTodos함수 실행으로 검색되게 수정
    settimeout 및 clearTimeout으로 지연검색 하게 변경
    let timeout= null;
      watch(searchText,async()=>{ 
        clearTimeout(timeout);
        
        timeout = setTimeout(()=>{
          getTodos(1);          
        },1500)
        
      })

*vue router
vue rounter설치 필요 npm install vuerouter@3 인가?
이우 router폴더 생성후 index.js생성
거기서 router설정 정보 설정 
url별 보여줄 component생성 이경우 pages폴더 하위 

그리고 App.vue에서 
  <RouterView/>
  <router-view/>
  둘중 아무거나 사용하면 해당 /url에 생성한 component가 적용됨

    import TodoSimpleForm from './components/TodoSimple.vue';
    @의미는 src경로를 의미한대

*router-link
vuejs는 로딩시 모든소스를 가져와 설정한다 이후 데이터만 가져와서 template에 끼워 넣는식으로 동작하는데
a href같은 이동시 로딩이 일어나면서 모든 데이터를 다시 가져오는 비효율적인 일이 발생한다.
--> a태그를 router-link로 변경하면 페이지 로딩없이 이동 가능하게 된다 
<RouterLink class="nav-link" to="/todos">Todos</RouterLink>